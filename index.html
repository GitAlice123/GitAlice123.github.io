<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Alice&#39;s Notebook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Alice&#39;s Notebook">
<meta property="og:url" content="https://gitalice123.github.io/index.html">
<meta property="og:site_name" content="Alice&#39;s Notebook">
<meta property="og:locale">
<meta property="article:author" content="Alice Yu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Alice's Notebook" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Alice&#39;s Notebook</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://GitAlice123.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-实验室服务器nccl部署命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/04/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8nccl%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2024-12-04T08:53:34.000Z" itemprop="datePublished">2024-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/04/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8nccl%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/">实验室服务器nccl部署命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="nccl编译"><a href="#nccl编译" class="headerlink" title="nccl编译"></a>nccl编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make src.build CUDA_HOME=/usr/lib/nvidia-cuda-toolkit/ NVCC_GENCODE=<span class="string">&quot;-gencode=arch=compute_80,code=sm_80&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="查看各种库的安装路径"><a href="#查看各种库的安装路径" class="headerlink" title="查看各种库的安装路径"></a>查看各种库的安装路径</h1><ul>
<li>由于管理员最初好像是用apt安装的，所以可以这样查找</li>
<li>以查找mpi为例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S mpicc</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="nccl-test编译"><a href="#nccl-test编译" class="headerlink" title="nccl-test编译"></a>nccl-test编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make MPI=1 MPI_HOME=/usr/mpi/gcc/openmpi-4.1.7a1 CUDA_HOME=/usr/lib/nvidia-cuda-toolkit/ NCCL_HOME=/home/cyu/tccl-2024/nccl/build</span><br></pre></td></tr></table></figure>

<h1 id="nccl-test测试"><a href="#nccl-test测试" class="headerlink" title="nccl-test测试"></a>nccl-test测试</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/cyu/tccl-2024/nccl/build/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./build/all_reduce_perf -b 8 -e 128M -f 2 -g 2</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitalice123.github.io/2024/12/04/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8nccl%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/" data-id="cm49nxf460004xsefdjgxbpp6" data-title="实验室服务器nccl部署命令" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/04/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2024-12-04T08:43:26.000Z" itemprop="datePublished">2024-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/04/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">hexo常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="本地重新生成静态文件"><a href="#本地重新生成静态文件" class="headerlink" title="本地重新生成静态文件"></a>本地重新生成静态文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h1 id="发布到github-io"><a href="#发布到github-io" class="headerlink" title="发布到github.io"></a>发布到github.io</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitalice123.github.io/2024/12/04/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="cm49nxf490006xsefeye5d6v1" data-title="hexo常用命令" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-NCCL使用示例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/29/NCCL%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-11-29T07:01:43.000Z" itemprop="datePublished">2024-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/29/NCCL%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">NCCL使用示例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="通信组创建和销毁"><a href="#通信组创建和销毁" class="headerlink" title="通信组创建和销毁"></a>通信组创建和销毁</h1><h2 id="一个进程，一个线程，多个设备"><a href="#一个进程，一个线程，多个设备" class="headerlink" title="一个进程，一个线程，多个设备"></a>一个进程，一个线程，多个设备</h2><ul>
<li>在这种单进程的场景下，可以使用ncclCommInitAll()<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    ncclComm_t comms[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// managing 4 devices</span></span><br><span class="line">    <span class="type">int</span> nDev = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="type">int</span> devs[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分的解释见《NCCL代码中NCCL代码中常用的函数和宏定义》的cudaAlloc部分</span></span><br><span class="line">    <span class="comment">// allocating and initializing device buffers</span></span><br><span class="line">    <span class="type">float</span> **sendbuff = (<span class="type">float</span> **)<span class="built_in">malloc</span>(nDev * <span class="keyword">sizeof</span>(<span class="type">float</span> *));</span><br><span class="line">    <span class="type">float</span> **recvbuff = (<span class="type">float</span> **)<span class="built_in">malloc</span>(nDev * <span class="keyword">sizeof</span>(<span class="type">float</span> *));</span><br><span class="line">    cudaStream_t *s = (cudaStream_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cudaStream_t) * nDev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nDev; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CUDACHECK(cudaSetDevice(i));</span><br><span class="line">        CUDACHECK(cudaMalloc((<span class="type">void</span> **)sendbuff + i, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">        CUDACHECK(cudaMalloc((<span class="type">void</span> **)recvbuff + i, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">        CUDACHECK(cudaMemset(sendbuff[i], <span class="number">1</span>, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">        CUDACHECK(cudaMemset(recvbuff[i], <span class="number">0</span>, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">        CUDACHECK(cudaStreamCreate(s + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initializing NCCL</span></span><br><span class="line">    NCCLCHECK(ncclCommInitAll(comms, nDev, devs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calling NCCL communication API. Group API is required when using</span></span><br><span class="line">    <span class="comment">// multiple devices per thread</span></span><br><span class="line">    <span class="comment">// 单线程控制多个GPU时必须要用group API，否则会死锁</span></span><br><span class="line">    NCCLCHECK(ncclGroupStart());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nDev; ++i)</span><br><span class="line">        NCCLCHECK(ncclAllReduce((<span class="type">const</span> <span class="type">void</span> *)sendbuff[i], (<span class="type">void</span> *)recvbuff[i], size, ncclFloat, ncclSum,</span><br><span class="line">                                comms[i], s[i]));</span><br><span class="line">    NCCLCHECK(ncclGroupEnd());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronizing on CUDA streams to wait for completion of NCCL operation</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nDev; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CUDACHECK(cudaSetDevice(i));</span><br><span class="line">        CUDACHECK(cudaStreamSynchronize(s[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free device buffers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nDev; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CUDACHECK(cudaSetDevice(i));</span><br><span class="line">        CUDACHECK(cudaFree(sendbuff[i]));</span><br><span class="line">        CUDACHECK(cudaFree(recvbuff[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finalizing NCCL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nDev; ++i)</span><br><span class="line">        ncclCommDestroy(comms[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Success \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitalice123.github.io/2024/11/29/NCCL%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" data-id="cm49nxf430003xsef7ljg5gma" data-title="NCCL使用示例" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-NCCL中重要的数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/29/NCCL%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2024-11-29T02:06:36.000Z" itemprop="datePublished">2024-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/29/NCCL%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">NCCL中重要的数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="struct-ncclComm"><a href="#struct-ncclComm" class="headerlink" title="struct ncclComm"></a>struct ncclComm</h1><p>实际使用的时候是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ncclComm</span>* <span class="title">ncclComm_t</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在src\nccl.h.in</li>
<li>通信上下文<br>开会，那么这个通信上下文就是会议室</li>
</ul>
<h1 id="struct-ncclInfo"><a href="#struct-ncclInfo" class="headerlink" title="struct ncclInfo"></a>struct ncclInfo</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitalice123.github.io/2024/11/29/NCCL%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cm49nxf3z0001xsefcny52fn6" data-title="NCCL中重要的数据结构" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-NCCL代码中常用的函数和宏定义" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/29/NCCL%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-29T02:05:31.000Z" itemprop="datePublished">2024-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/29/NCCL%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89/">NCCL代码中常用的函数和宏定义</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NCCLCHECK"><a href="#NCCLCHECK" class="headerlink" title="NCCLCHECK"></a>NCCLCHECK</h1><p><code>NCCLCHECK</code> 是一个宏，用于简化 NCCL 函数调用后的错误检查。在 NCCL 和许多 C&#x2F;C++ 编程环境中，错误处理通常是一个关键部分，而通过宏封装可以使代码更加简洁和易于维护。</p>
<hr>
<h2 id="NCCLCHECK-的典型定义"><a href="#NCCLCHECK-的典型定义" class="headerlink" title="NCCLCHECK 的典型定义"></a><strong>NCCLCHECK 的典型定义</strong></h2><p>在 NCCL 的代码中，<code>NCCLCHECK</code> 通常是定义为类似下面的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NCCLCHECK(call) do &#123; \</span></span><br><span class="line"><span class="meta">  ncclResult_t result = call; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (result != ncclSuccess) &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;NCCL error at %s:%d: %s\n&quot;</span>, __FILE__, __LINE__, ncclGetErrorString(result)); \</span></span><br><span class="line"><span class="meta">    return result; \</span></span><br><span class="line"><span class="meta">  &#125; \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h2><ol>
<li><p><strong>执行函数调用并捕获返回值</strong><br><code>call</code> 是需要执行的 NCCL 函数，比如 <code>ncclInit()</code> 或 <code>PtrCheck(out, &quot;GetUniqueId&quot;, &quot;out&quot;)</code>。这些函数通常返回一个类型为 <code>ncclResult_t</code> 的结果，用于指示是否成功。</p>
</li>
<li><p><strong>检查返回值是否成功</strong><br>如果 <code>call</code> 返回的值不是 <code>ncclSuccess</code>，则表示调用失败。</p>
</li>
<li><p><strong>打印调试信息</strong><br>如果失败，宏会打印文件名、行号以及错误字符串。<code>ncclGetErrorString</code> 是 NCCL 提供的函数，可以将错误码转换为可读的错误消息。</p>
</li>
<li><p><strong>中止当前流程</strong><br>如果函数调用失败，<code>NCCLCHECK</code> 通常会返回错误码，退出当前函数。</p>
</li>
</ol>
<hr>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h2><p>在代码中，<code>NCCLCHECK</code> 的作用是捕获和处理 NCCL 函数的错误。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NCCLCHECK(ncclInit());</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ncclResult_t result = ncclInit();</span><br><span class="line">  <span class="keyword">if</span> (result != ncclSuccess) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NCCL error at %s:%d: %s\n&quot;</span>, __FILE__, __LINE__, ncclGetErrorString(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代码中的用途"><a href="#代码中的用途" class="headerlink" title="代码中的用途"></a><strong>代码中的用途</strong></h2><p>在 <code>ncclGetUniqueId</code> 函数中，<code>NCCLCHECK</code> 用来确保：</p>
<ol>
<li><p><strong>NCCL 初始化成功：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NCCLCHECK(ncclInit());</span><br></pre></td></tr></table></figure>
<p>如果 <code>ncclInit()</code> 返回错误码，函数将立即返回错误。</p>
</li>
<li><p><strong>指针有效性检查：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NCCLCHECK(PtrCheck(out, <span class="string">&quot;GetUniqueId&quot;</span>, <span class="string">&quot;out&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果 <code>out</code> 指针无效或检查失败，函数会打印错误信息并返回。</p>
</li>
<li><p><strong>调用其他 NCCL 函数的结果处理：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NCCLCHECK(bootstrapGetUniqueId(&amp;handle));</span><br></pre></td></tr></table></figure>
<p>如果获取 unique ID 的操作失败，也会立即退出并返回错误。</p>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><code>NCCLCHECK</code> 是一个宏，用于简化和统一错误处理的逻辑。它的主要功能是：</p>
<ol>
<li>调用 NCCL 函数并捕获返回值。</li>
<li>检查返回值是否成功。</li>
<li>如果失败，打印调试信息，并退出当前函数。</li>
</ol>
<h1 id="cudaSetDevice"><a href="#cudaSetDevice" class="headerlink" title="cudaSetDevice"></a>cudaSetDevice</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaSetDevice</span><span class="params">(<span class="type">int</span> device)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实这并不是一个NCCL的函数，而是一个CUDA runtime的API</li>
<li>用于设置当前线程的CUDA设备(GPU)</li>
<li>就是说，我现在如果调用了cudaSetDevice(1)，那么接下来的CUDA函数调用都会在GPU 1上执行（我在操作1号设备），直到我再次对另一个设备调用cudaSetDevice</li>
</ul>
<h1 id="cudaMalloc"><a href="#cudaMalloc" class="headerlink" title="cudaMalloc"></a>cudaMalloc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMalloc</span><span class="params">(<span class="type">void</span>** devPtr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>为设备分配内存，这个设备就是之前用cudaSetDevice设置的设备</li>
<li>devPtr是一个指向指针的指针，指向的指针存的是分配的内存的地址</li>
<li>举例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocating and initializing device buffers</span></span><br><span class="line"><span class="type">float</span> **sendbuff = (<span class="type">float</span> **)<span class="built_in">malloc</span>(nDev * <span class="keyword">sizeof</span>(<span class="type">float</span> *));</span><br><span class="line"><span class="type">float</span> **recvbuff = (<span class="type">float</span> **)<span class="built_in">malloc</span>(nDev * <span class="keyword">sizeof</span>(<span class="type">float</span> *));</span><br><span class="line">cudaStream_t *s = (cudaStream_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cudaStream_t) * nDev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nDev; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    CUDACHECK(cudaSetDevice(i));</span><br><span class="line">    CUDACHECK(cudaMalloc((<span class="type">void</span> **)sendbuff + i, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    CUDACHECK(cudaMalloc((<span class="type">void</span> **)recvbuff + i, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    CUDACHECK(cudaMemset(sendbuff[i], <span class="number">1</span>, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    CUDACHECK(cudaMemset(recvbuff[i], <span class="number">0</span>, size * <span class="keyword">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    CUDACHECK(cudaStreamCreate(s + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="./NCCL代码中常用的函数和宏定义/3a3ee784d1c88e46f7bd139614358f46.jpg" width="50%">


<h1 id="group-API"><a href="#group-API" class="headerlink" title="group API"></a>group API</h1><h3 id="1-Group-Calls-组调用-的概念"><a href="#1-Group-Calls-组调用-的概念" class="headerlink" title="1. Group Calls (组调用) 的概念"></a>1. <strong>Group Calls (组调用) 的概念</strong></h3><p><code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 是 NCCL 提供的两个函数，用于将多个 NCCL 操作合并成一个操作进行执行。这些操作会在同一个 <strong>NCCL group</strong> 内顺序执行，从而减少了多次启动 NCCL 操作时的开销。通过使用组调用，NCCL 可以更高效地管理并发操作，尤其是在涉及多个 GPU 或多线程的场景下。</p>
<ul>
<li><p>**<code>ncclGroupStart()</code>**：启动一个 NCCL 操作组。所有在这个调用后到 <code>ncclGroupEnd()</code> 之前的 NCCL 操作都会被视作同一个组的一部分。</p>
</li>
<li><p>**<code>ncclGroupEnd()</code>**：结束 NCCL 操作组，并提交所有在 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 之间的操作。调用这个函数后，NCCL 会将所有操作打包在一起，并尽可能高效地执行。</p>
</li>
</ul>
<h3 id="2-Group-Calls-的使用场景"><a href="#2-Group-Calls-的使用场景" class="headerlink" title="2. Group Calls 的使用场景"></a>2. <strong>Group Calls 的使用场景</strong></h3><ul>
<li><p><strong>管理多个 GPU</strong>：在单线程管理多个 GPU 时，使用组调用可以避免死锁，并提高多 GPU 操作的并行性。例如，多个 <code>ncclAllReduce</code> 操作可以并行执行，而不是一个接一个地执行，这样可以减少执行延迟。</p>
</li>
<li><p><strong>聚合通信操作</strong>：通过将多个 NCCL 集体通信操作合并到一个 NCCL 调用组中，可以显著提高性能，减少启动多个 NCCL 操作时的延迟。</p>
</li>
<li><p><strong>合并多个点对点通信操作</strong>：点对点通信（例如 <code>ncclSend</code> 和 <code>ncclRecv</code>）也可以通过组调用合并，减少启动操作时的延迟。</p>
</li>
</ul>
<p>好的，让我们更深入地探讨每个示例，并解释如果不使用组调用（<code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code>），会发生什么，执行的具体过程是怎样的。</p>
<h3 id="1-管理多个-GPU-的通信操作"><a href="#1-管理多个-GPU-的通信操作" class="headerlink" title="1. 管理多个 GPU 的通信操作"></a>1. <strong>管理多个 GPU 的通信操作</strong></h3><h4 id="示例：多个设备上的-ncclAllReduce"><a href="#示例：多个设备上的-ncclAllReduce" class="headerlink" title="示例：多个设备上的 ncclAllReduce"></a>示例：多个设备上的 <code>ncclAllReduce</code></h4><p>假设我们有多个 GPU（例如 4 个），并希望在每个 GPU 上执行相同的 NCCL 操作（例如 <code>ncclAllReduce</code>）。不使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 时，你可能会在每个 GPU 上执行一次 <code>ncclAllReduce</code> 操作，每次都可能会等待前一个操作完成，这样会增加执行时间和延迟。</p>
<h5 id="使用-ncclGroupStart-和-ncclGroupEnd"><a href="#使用-ncclGroupStart-和-ncclGroupEnd" class="headerlink" title="使用 ncclGroupStart() 和 ncclGroupEnd()"></a>使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclGroupStart</span>();  <span class="comment">// 开始一个 NCCL 操作组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">  <span class="built_in">ncclAllReduce</span>(..., comm[i], stream[i]);  <span class="comment">// 在多个 GPU 上执行操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ncclGroupEnd</span>();  <span class="comment">// 结束并执行所有操作</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在这里，<code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 包围了所有的 <code>ncclAllReduce</code> 调用，所有操作会被视为同一个组的一部分。</li>
<li><strong>执行顺序</strong>：NCCL 会在后台调度这些操作并行执行。每个 GPU 上的操作并不会阻塞其他操作的执行。</li>
<li><strong>性能</strong>：所有 GPU 上的 <code>ncclAllReduce</code> 操作可以并行执行，减少了同步和启动开销。</li>
</ul>
<h5 id="不使用-ncclGroupStart-和-ncclGroupEnd"><a href="#不使用-ncclGroupStart-和-ncclGroupEnd" class="headerlink" title="不使用 ncclGroupStart() 和 ncclGroupEnd()"></a>不使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">  <span class="built_in">ncclAllReduce</span>(..., comm[i], stream[i]);  <span class="comment">// 在多个 GPU 上执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>执行顺序</strong>：如果不使用组调用，NCCL 会逐个执行这些 <code>ncclAllReduce</code> 操作，<strong>等待每个操作完成后再执行下一个操作</strong>。</p>
<ul>
<li>比如，假设有 4 个 GPU，<code>ncclAllReduce</code> 操作会依次执行，每次执行时都会等待前一个操作完成，然后才会开始下一个操作。这种顺序执行会导致明显的延迟。</li>
</ul>
</li>
<li><p><strong>死锁风险</strong>：如果在每个操作中都需要同步，且这些操作依赖于其他线程&#x2F;进程的结果，可能会导致死锁或不必要的阻塞。例如，<code>ncclAllReduce</code> 在每个设备上执行时，可能需要等待所有设备的操作完成。如果每个设备操作的顺序不一致，可能导致不必要的等待或冲突。</p>
</li>
</ul>
<h3 id="2-在创建通信器时使用-Group-Calls"><a href="#2-在创建通信器时使用-Group-Calls" class="headerlink" title="2. 在创建通信器时使用 Group Calls"></a>2. <strong>在创建通信器时使用 Group Calls</strong></h3><h4 id="示例：在一个线程中管理多个-GPU"><a href="#示例：在一个线程中管理多个-GPU" class="headerlink" title="示例：在一个线程中管理多个 GPU"></a>示例：在一个线程中管理多个 GPU</h4><p>假设你有一个线程需要初始化多个 GPU 上的 NCCL 通信器。初始化操作（如 <code>ncclCommInitRank</code>）通常是一个阻塞操作，如果不使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code>，这些初始化操作会依次执行，每次操作都必须等待前一个操作完成，这可能会浪费时间。</p>
<h5 id="使用-ncclGroupStart-和-ncclGroupEnd-1"><a href="#使用-ncclGroupStart-和-ncclGroupEnd-1" class="headerlink" title="使用 ncclGroupStart() 和 ncclGroupEnd()"></a>使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclGroupStart</span>();  <span class="comment">// 开始一个 NCCL 操作组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">  <span class="built_in">cudaSetDevice</span>(device[i]);  <span class="comment">// 设置当前 GPU</span></span><br><span class="line">  <span class="built_in">ncclCommInitRank</span>(comms + i, nranks, commId, rank[i]);  <span class="comment">// 初始化通信器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ncclGroupEnd</span>();  <span class="comment">// 结束并执行所有操作</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行顺序</strong>：<code>ncclCommInitRank</code> 调用会并行地在每个 GPU 上执行。</li>
<li><strong>性能</strong>：因为通信器的初始化操作是通过组调用来管理的，NCCL 可以在后台并行处理所有设备的初始化操作，而不是一个接一个地执行。这减少了初始化的时间。</li>
</ul>
<h5 id="不使用-ncclGroupStart-和-ncclGroupEnd-1"><a href="#不使用-ncclGroupStart-和-ncclGroupEnd-1" class="headerlink" title="不使用 ncclGroupStart() 和 ncclGroupEnd()"></a>不使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">  <span class="built_in">cudaSetDevice</span>(device[i]);  <span class="comment">// 设置当前 GPU</span></span><br><span class="line">  <span class="built_in">ncclCommInitRank</span>(comms + i, nranks, commId, rank[i]);  <span class="comment">// 初始化通信器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行顺序</strong>：<code>ncclCommInitRank</code> 会按顺序执行，等待每个设备的初始化完成后再继续执行下一个设备的初始化。</li>
<li><strong>性能</strong>：没有组调用，通信器初始化会串行执行，导致设备初始化时间更长。如果有多个 GPU，这会浪费很多时间在设备间的同步和等待上。</li>
</ul>
<h3 id="3-聚合通信操作"><a href="#3-聚合通信操作" class="headerlink" title="3. 聚合通信操作"></a>3. <strong>聚合通信操作</strong></h3><h4 id="示例：多个集体操作（ncclBroadcast-和-ncclAllReduce）聚合"><a href="#示例：多个集体操作（ncclBroadcast-和-ncclAllReduce）聚合" class="headerlink" title="示例：多个集体操作（ncclBroadcast 和 ncclAllReduce）聚合"></a>示例：多个集体操作（<code>ncclBroadcast</code> 和 <code>ncclAllReduce</code>）聚合</h4><p>假设你想在多个 GPU 上执行多个不同的 NCCL 集体操作（例如，一个 <code>ncclBroadcast</code> 和两个 <code>ncclAllReduce</code>）。如果不使用组调用，NCCL 会为每个操作单独启动一次通信。</p>
<h5 id="使用-ncclGroupStart-和-ncclGroupEnd-2"><a href="#使用-ncclGroupStart-和-ncclGroupEnd-2" class="headerlink" title="使用 ncclGroupStart() 和 ncclGroupEnd()"></a>使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclGroupStart</span>();  <span class="comment">// 开始 NCCL 操作组</span></span><br><span class="line"><span class="built_in">ncclBroadcast</span>(sendbuff1, recvbuff1, count1, datatype, root, comm, stream);</span><br><span class="line"><span class="built_in">ncclAllReduce</span>(sendbuff2, recvbuff2, count2, datatype, comm, stream);</span><br><span class="line"><span class="built_in">ncclAllReduce</span>(sendbuff3, recvbuff3, count3, datatype, comm, stream);</span><br><span class="line"><span class="built_in">ncclGroupEnd</span>();  <span class="comment">// 结束并执行所有操作</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行顺序</strong>：所有的集体操作（<code>ncclBroadcast</code> 和 <code>ncclAllReduce</code>）会被合并到一个组中执行。NCCL 会将这些操作作为一个批次提交，减少了每个操作单独启动时的开销。</li>
<li><strong>性能</strong>：通过将多个操作合并成一个组，NCCL 只需要发起一次通信并等待完成，从而减少了启动和同步的延迟。</li>
</ul>
<h5 id="不使用-ncclGroupStart-和-ncclGroupEnd-2"><a href="#不使用-ncclGroupStart-和-ncclGroupEnd-2" class="headerlink" title="不使用 ncclGroupStart() 和 ncclGroupEnd()"></a>不使用 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclBroadcast</span>(sendbuff1, recvbuff1, count1, datatype, root, comm, stream);</span><br><span class="line"><span class="built_in">ncclAllReduce</span>(sendbuff2, recvbuff2, count2, datatype, comm, stream);</span><br><span class="line"><span class="built_in">ncclAllReduce</span>(sendbuff3, recvbuff3, count3, datatype, comm, stream);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行顺序</strong>：每个 <code>ncclBroadcast</code> 和 <code>ncclAllReduce</code> 操作都会单独执行，NCCL 会依次启动每个操作并等待前一个操作完成。这样，可能会在每个操作之间产生额外的延迟，尤其是在启动多个 NCCL 操作时。</li>
<li><strong>性能</strong>：每个操作都会带来额外的启动开销，导致总体性能下降。</li>
</ul>
<h3 id="4-非阻塞组操作"><a href="#4-非阻塞组操作" class="headerlink" title="4. 非阻塞组操作"></a>4. <strong>非阻塞组操作</strong></h3><p>在非阻塞模式下，<code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 仍然有用。因为非阻塞通信器可能会返回 <code>ncclInProgress</code>，表示操作还在进行中。这时，我们需要确保 NCCL 内核已发出操作，才能进行后续操作（例如，等待 CUDA 流同步）。</p>
<h5 id="使用非阻塞组操作"><a href="#使用非阻塞组操作" class="headerlink" title="使用非阻塞组操作"></a>使用非阻塞组操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclGroupStart</span>();  <span class="comment">// 开始 NCCL 操作组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> g = <span class="number">0</span>; g &lt; ngpus; g++) &#123;</span><br><span class="line">  <span class="built_in">ncclAllReduce</span>(sendbuffs[g] + offsets[i], recvbuffs[g] + offsets[i], counts[i], datatype[i], comms[g], streams[g]);</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">ncclGroupEnd</span>();  <span class="comment">// 结束操作组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == ncclInProgress) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> g = <span class="number">0</span>; g &lt; ngpus; g++) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="built_in">ncclCommGetAsyncError</span>(comms[g], &amp;state);  <span class="comment">// 检查通信器的异步错误状态</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (state == ncclInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == ncclSuccess) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;NCCL kernel issue succeeded\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">reportErrorAndRestart</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> g = <span class="number">0</span>; g &lt; ngpus; g++) &#123;</span><br><span class="line">  <span class="built_in">cudaStreamSynchronize</span>(streams[g]);  <span class="comment">// 等待所有流同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行顺序</strong>：如果 NCCL 操作是非阻塞的，<code>ncclGroupEnd()</code> 返回后，不一定所有操作都已经发出。<code>ncclInProgress</code> 表示操作仍在后台发出，用户需要检查操作是否完成（通过 <code>ncclCommGetAsyncError</code>），然后等待 CUDA 流同步。</li>
</ul>
<h5 id="不使用非阻塞组操作"><a href="#不使用非阻塞组操作" class="headerlink" title="不使用非阻塞组操作"></a>不使用非阻塞组操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> g = <span class="number">0</span>; g &lt; ngpus; g++) &#123;</span><br><span class="line">  <span class="built_in">ncclAllReduce</span>(sendbuffs[g] + offsets[i], recvbuffs[g] + offsets[i], counts[i], datatype[i], comms[g], streams[g]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cudaStreamSynchronize</span>(streams[g]);  <span class="comment">// 等待所有流同步</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行顺序</strong>：每个 <code>ncclAllReduce</code> 操作是同步的，会在每个 GPU 上依次执行，直到所有操作完成</li>
</ul>
<p>在 NCCL 中，”阻塞组”（Blocking Group）和”非阻塞组”（Non-blocking Group）指的是如何处理多个通信操作的并行执行以及如何同步它们。具体来说，这与多个通信操作在 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 之间的执行方式以及返回值相关。</p>
<h3 id="1-阻塞组（Blocking-Group）"><a href="#1-阻塞组（Blocking-Group）" class="headerlink" title="1. 阻塞组（Blocking Group）"></a>1. <strong>阻塞组（Blocking Group）</strong></h3><p><strong>阻塞组</strong>意味着当调用 <code>ncclGroupEnd()</code> 时，NCCL 会<strong>等待</strong>所有在 <code>ncclGroupStart()</code> 和 <code>ncclGroupEnd()</code> 之间的 NCCL 操作完全完成（包括启动、执行和同步）。在这种模式下，<code>ncclGroupEnd()</code> 会在所有操作完成后返回，意味着直到所有操作完成，你才能继续执行后续的代码。</p>
<h4 id="阻塞组的特点："><a href="#阻塞组的特点：" class="headerlink" title="阻塞组的特点："></a>阻塞组的特点：</h4><ul>
<li>所有组中的 NCCL 操作会按顺序依次发起并等待完成。</li>
<li><code>ncclGroupEnd()</code> 会<strong>阻塞</strong>直到所有 NCCL 操作都完成。</li>
<li>阻塞组适用于你希望在继续执行其他任务之前等待所有 NCCL 操作完成的场景。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclGroupStart</span>();  <span class="comment">// 开始一个 NCCL 操作组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">  <span class="built_in">ncclAllReduce</span>(..., comm[i], stream[i]);  <span class="comment">// 在多个 GPU 上执行操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ncclGroupEnd</span>();  <span class="comment">// 等待所有操作完成</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ncclGroupEnd()</code> 会阻塞，直到所有的 <code>ncclAllReduce</code> 操作完成。这样可以确保在 <code>ncclGroupEnd()</code> 返回之前，所有的 NCCL 操作都已经被提交和执行。</p>
<h3 id="2-非阻塞组（Non-blocking-Group）"><a href="#2-非阻塞组（Non-blocking-Group）" class="headerlink" title="2. 非阻塞组（Non-blocking Group）"></a>2. <strong>非阻塞组（Non-blocking Group）</strong></h3><p><strong>非阻塞组</strong>指的是当你调用 <code>ncclGroupEnd()</code> 时，NCCL 并不会阻塞直到所有操作完成。相反，<code>ncclGroupEnd()</code> 会尽快返回，并表示操作组已被提交，但后台的 NCCL 操作可能仍在执行中。这种模式允许你执行其他任务，同时在后台继续完成 NCCL 操作。</p>
<ul>
<li><strong>非阻塞组</strong>的核心是当 <code>ncclGroupEnd()</code> 返回时，NCCL 操作可能仍在后台执行。这时你可以检查操作是否完成（通过查看返回状态或使用异步错误检查），而不是等待它们同步完成。</li>
<li>非阻塞组适用于你希望进行并行操作或不希望阻塞主线程的场景，例如，你希望继续执行其他计算或通信操作，而不是等待每个 NCCL 操作完成。</li>
</ul>
<h4 id="非阻塞组的特点："><a href="#非阻塞组的特点：" class="headerlink" title="非阻塞组的特点："></a>非阻塞组的特点：</h4><ul>
<li><code>ncclGroupEnd()</code> 会尽快返回，不会等待所有操作完成。</li>
<li>当组中的操作还在后台执行时，<code>ncclGroupEnd()</code> 会返回 <code>ncclInProgress</code>，表示操作仍在进行。</li>
<li>你可以通过调用 <code>ncclCommGetAsyncError()</code> 来检查操作的状态，以便确认 NCCL 操作是否完成。</li>
<li>如果使用非阻塞组，通常需要在后续代码中进行同步（如调用 <code>cudaStreamSynchronize()</code>）来确保所有操作完成。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ncclGroupStart</span>();  <span class="comment">// 开始一个 NCCL 操作组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">  <span class="built_in">ncclAllReduce</span>(..., comm[i], stream[i]);  <span class="comment">// 在多个 GPU 上执行操作</span></span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">ncclGroupEnd</span>();  <span class="comment">// 不等待所有操作完成，尽快返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞操作完成时的处理</span></span><br><span class="line"><span class="keyword">if</span> (ret == ncclInProgress) &#123;</span><br><span class="line">  <span class="comment">// 检查操作是否完成</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nLocalDevs; i++) &#123;</span><br><span class="line">    <span class="built_in">ncclCommGetAsyncError</span>(comm[i], &amp;state);</span><br><span class="line">    <span class="keyword">while</span> (state == ncclInProgress) &#123;</span><br><span class="line">      <span class="comment">// 等待操作完成</span></span><br><span class="line">      <span class="built_in">ncclCommGetAsyncError</span>(comm[i], &amp;state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ncclGroupEnd()</code> 会尽快返回，并可能返回 <code>ncclInProgress</code>，表示 NCCL 操作仍在后台进行。你可以通过调用 <code>ncclCommGetAsyncError()</code> 来轮询每个操作的状态，并在操作完成时继续执行后续代码。</p>
<h3 id="3-阻塞与非阻塞的区别"><a href="#3-阻塞与非阻塞的区别" class="headerlink" title="3. 阻塞与非阻塞的区别"></a>3. <strong>阻塞与非阻塞的区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>阻塞组（Blocking Group）</th>
<th>非阻塞组（Non-blocking Group）</th>
</tr>
</thead>
<tbody><tr>
<td><code>ncclGroupEnd()</code> 返回时的状态</td>
<td>阻塞，直到所有操作完成</td>
<td>不会阻塞，可能返回 <code>ncclInProgress</code>（操作仍在进行）</td>
</tr>
<tr>
<td>是否等待操作完成</td>
<td>是，<code>ncclGroupEnd()</code> 会等待所有操作完成</td>
<td>否，<code>ncclGroupEnd()</code> 会尽快返回</td>
</tr>
<tr>
<td>操作是否并行进行</td>
<td>是，操作仍然会并行进行，但会阻塞等待完成</td>
<td>是，操作并行进行，但不等待所有操作完成</td>
</tr>
<tr>
<td>后续操作的执行时机</td>
<td>只有当所有 NCCL 操作完成后才能继续执行后续代码</td>
<td>可以在后台完成操作时继续执行其他任务</td>
</tr>
<tr>
<td>错误检查</td>
<td>一般不需要异步错误检查，因为操作会同步执行</td>
<td>需要通过 <code>ncclCommGetAsyncError()</code> 等检查操作状态</td>
</tr>
</tbody></table>
<h3 id="4-何时使用阻塞组和非阻塞组"><a href="#4-何时使用阻塞组和非阻塞组" class="headerlink" title="4. 何时使用阻塞组和非阻塞组"></a>4. <strong>何时使用阻塞组和非阻塞组</strong></h3><ul>
<li><p><strong>阻塞组</strong>：</p>
<ul>
<li>当你需要确保所有 NCCL 操作在继续执行其他任务之前都已经完成时，使用阻塞组。例如，当你依赖前面的操作结果进行计算时，必须等待所有操作完成。</li>
<li>在大多数情况下，如果你不需要处理并行任务或不需要优化延迟，阻塞组是默认选择。</li>
</ul>
</li>
<li><p><strong>非阻塞组</strong>：</p>
<ul>
<li>当你希望在 NCCL 操作还在进行时执行其他任务时，使用非阻塞组。例如，你可以在发起多个 NCCL 操作后，继续执行其他计算任务，而不需要等待这些操作完成。</li>
<li>非阻塞组对于需要最大化计算和通信重叠（overlap）的场景非常有用，特别是在需要执行多个独立的计算任务并行时。</li>
</ul>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>阻塞组</strong>的 <code>ncclGroupEnd()</code> 会等待所有的 NCCL 操作完成后才返回，适合在操作完成后继续执行后续任务。</li>
<li><strong>非阻塞组</strong>的 <code>ncclGroupEnd()</code> 会尽快返回，不会等待所有操作完成，适合在后台执行操作的同时继续其他任务，或者减少阻塞等待时间。</li>
</ul>
<p>选择是否使用阻塞组或非阻塞组，取决于你的应用场景和对延迟的容忍度。如果你希望提高并行性和重叠计算与通信，非阻塞组是一个更好的选择；如果你需要确保所有操作完成后再进行下一步，阻塞组则更合适。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitalice123.github.io/2024/11/29/NCCL%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89/" data-id="cm49nxf480005xsefe6kze7p0" data-title="NCCL代码中常用的函数和宏定义" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-NCCL代码阅读-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/28/NCCL%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-01/" class="article-date">
  <time class="dt-published" datetime="2024-11-28T07:45:03.000Z" itemprop="datePublished">2024-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/28/NCCL%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-01/">NCCL代码阅读-01</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="创建一个通信组-communicator"><a href="#创建一个通信组-communicator" class="headerlink" title="创建一个通信组(communicator)"></a>创建一个通信组(communicator)</h1><ul>
<li>创建一个通信组之前，每个CUDA设备都要被分配一个唯一的rank id</li>
<li>有了这个rank id和CUDA设备的静态映射，ncclCommInitRank(), ncclCommInitRankConfig() and ncclCommInitAll() 三个函数会创建communicator objects，每个communicator object会和一个固定的rank（及一个CUDA设备）关联。</li>
<li>在调用ncclCommInitRank之前，需要调用ncclGetUniqueId()来获取一个unique id，这个ID必须广播到所有参与通信的进程，让他们知道自己在communicator中</li>
<li>比如有四个GPU互相通信，加入了一个通信组，那么这个通信组就需要一个通信上下文记录所有的信息</li>
<li>类比四个人开会，那么这个通信上下文就是会议室</li>
</ul>
<h2 id="ncclCommInitRank"><a href="#ncclCommInitRank" class="headerlink" title="ncclCommInitRank"></a>ncclCommInitRank</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncclResult_t <span class="title function_">ncclCommInitRank</span><span class="params">(ncclComm_t* comm, <span class="type">int</span> nranks, ncclUniqueId commId, <span class="type">int</span> rank)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个communicator object</li>
<li>里面调用ncclCommInitRankDev()</li>
</ul>
<h2 id="ncclCommInitAll"><a href="#ncclCommInitAll" class="headerlink" title="ncclCommInitAll"></a>ncclCommInitAll</h2><ul>
<li>在<strong>一个CPU进程</strong>里面执行(<strong>因此他后面所调用的所有函数都是在这一个进程，一个线程里面执行的</strong>)，创建多个communicator object</li>
<li>但是只能是单进程版本，也因此不支持多node通信</li>
<li>首先检查了各种数据的有效性</li>
<li>然后调用ncclGetUniqueId()获取一个unique id<ul>
<li>ncclGetUniqueId()首先调用ncclInit()初始化NCCL</li>
</ul>
</li>
</ul>
<h2 id="ncclInit"><a href="#ncclInit" class="headerlink" title="ncclInit()"></a>ncclInit()</h2><ul>
<li>这是一个在所有线程中只会执行一次的函数</li>
<li>在两个地方被调用：ncclGetUniqueId和ncclCommInitRankDev</li>
<li>如果是ncclGetUniqueId调用的，那么分两种情况：<ul>
<li>在ncclCommInitAll中调用，那其实就一个进程，一个线程，不用担心会被多次调用</li>
<li>在ncclCommInitRank前面调用，那么就要限制只有第一个线程调用，后面的线程不会再调用</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitalice123.github.io/2024/11/28/NCCL%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-01/" data-id="cm49nxf410002xsef6gyshxzy" data-title="NCCL代码阅读-01" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/04/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8nccl%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/">实验室服务器nccl部署命令</a>
          </li>
        
          <li>
            <a href="/2024/12/04/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">hexo常用命令</a>
          </li>
        
          <li>
            <a href="/2024/11/29/NCCL%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/">NCCL使用示例</a>
          </li>
        
          <li>
            <a href="/2024/11/29/NCCL%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">NCCL中重要的数据结构</a>
          </li>
        
          <li>
            <a href="/2024/11/29/NCCL%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89/">NCCL代码中常用的函数和宏定义</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Alice Yu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>